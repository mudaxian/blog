---
title: 基础题
date: 2022-07-20 08:53:26
tags:
- 练习
categories:
- Java
---

# 基础题



## 一、==与equals的区别

### 1.==操作符

==操作符专门用来比较变量的值是否相同。

基本数据类型：比较的是他们的值是否相同。
引用数据类型：比较的是他们的内存地址是否同一地址。
引用类型对象变量其实是一个引用，它们的值是指向对象所在的内存地址，而不是对象本身。



### 2.equals方法

equals方法常用来比较对象的内容是否相同。

Java当中所有的类都是继承于Object这个超类的，在Object类中定义的equals方法：

```java
public boolean equals(Object obj) {
    return (this == obj);
}
```
未重写equals方法的类：Object中的equals方法实际使用的也是==操作符，比较的是他们的内存地址是否同一地址。
重写了equals方法的类：实现该类自己的equals方法比较逻辑（一般是比较对象的内容是否相同）。比如：
String：比较字符串内容，内容相同这相同；
Integer：比较对应的基本数据类型int的值是否相同（==操作符）。



## 二、final

### 1.概述


final关键字可用于多个场景，且在不同场景具有不同的作用。首先，final是一个非访问修饰符，仅适用于变量，方法或类。下面是使用final的不同场景：

![img](/img/final.png)

上面这张图可以概括成：

- 当final修饰变量时，被修饰的变量必须被初始化(赋值)，且后续不能修改其值，实质上是常量；
- 当final修饰方法时，被修饰的方法无法被所在类的子类重写（覆写）；
- 当final修饰类时，被修饰的类不能被继承，并且final类中的所有成员方法都会被隐式地指定为final方法，但成员变量则不会变。

### 2.final 修饰变量

当使用final关键字声明类成员变量或局部变量后，其值不能被再次修改；也经常和static关键字一起，作为类常量使用。很多时候会容易把static和final关键字混淆，static作用于成员变量用来表示只保存一份副本，而final的作用是用来保证变量不可变。如果final变量是引用，这意味着该变量不能重新绑定到引用另一个对象，但是可以更改该引用变量指向的对象的内部状态，即可以从final数组或final集合中添加或删除元素。最好用全部大写来表示final变量，使用下划线来分隔单词。
例子：

```java
//一个final成员常量
final int THRESHOLD = 5;
//一个空的final成员常量
final int THRESHOLD;
//一个静态final类常量
static final double PI = 3.141592653589793;
//一个空的静态final类常量
static final double PI;
```


而关于高效，是因为在java早期实现中，如果将一个方法指明为final，就是同意编译器将针对该方法的调用都转化为内嵌调用（内联）。大概就是，如果是内嵌调用，虚拟机不再执行正常的方法调用（参数压栈，跳转到方法处执行，再调回，处理栈参数，处理返回值），而是直接将方法展开，以方法体中的实际代码替代原来的方法调用。这样减少了方法调用的开销。所以有一些程序员认为：除非有足够的理由使用多态性，否则应该将所有的方法都用 final 修饰。这样的认识未免有些偏激，因为在最近的java设计中，虚拟机（特别是hotspot技术）可以自己去根据具体情况自动优化选择是否进行内联，只不过使用了final关键字的话可以显示地影响编译器对被修饰的代码进行内联优化。所以请切记，对于Java虚拟机来说编译器在编译期间会自动进行内联优化，这是由编译器决定的，对于开发人员来说，一定要设计好时空复杂度的平衡，不要滥用final。
注1：类的private方法会隐式地被指定为final方法，也就同样无法被重写。可以对private方法添加final修饰符，但并没有添加任何额外意义。
注2：在java中，你永远不会看到同时使用final和abstract关键字声明的类或方法。对于类，final用于防止继承，而抽象类反而需要依赖于它们的子类来完成实现。在修饰方法时，final用于防止被覆盖，而抽象方法反而需要在子类中被重写。

### 3.final 优化编码的艺术

final关键字在效率上的作用主要可以总结为以下三点：
缓存：final配合static关键字提高了代码性能，JVM和Java应用都会缓存final变量。
同步：final变量或对象是只读的，可以安全的在多线程环境下进行共享，而不需要额外的同步开销。
内联：使用final关键字，JVM会显式地主动对方法、变量及类进行内联优化。



## 三、String，StringBuffer和StringBuilder类的区别

### 1.区别

String 是 Java 中基础且重要的类，被声明为 final class，是不可变字符串。因为它的不可变性，所以拼接字符串时候会产生很多无用的中间对象，如果频繁的进行这样的操作对性能有所影响。

StringBuffer 就是为了解决大量拼接字符串时产生很多中间对象问题而提供的一个类。它提供了 append 和 add 方法，可以将字符串添加到已有序列的末尾或指定位置，它的本质是一个线程安全的可修改的字符序列。

在很多情况下我们的字符串拼接操作不需要线程安全，所以 StringBuilder 登场了。StringBuilder 是 JDK1.5 发布的，它和 StringBuffer 本质上没什么区别，就是去掉了保证线程安全的那部分，减少了开销。

### 2.线程安全：

StringBuffer：线程安全
StringBuilder：线程不安全

### 3.速度：

一般情况下，速度从快到慢为 StringBuilder > StringBuffer > String，当然这是相对的，不是绝对的。

### 4.使用环境：

操作少量的数据使用 String。
单线程操作大量数据使用 StringBuilder。
多线程操作大量数据使用 StringBuffer。



## 四、重载和重写的区别

### 1、首先是含义不同

1）方法重载是在同一个类中，声明多个同名方法，通过参数列表来区分不同的方法，与参数列表的数量、类型和顺序有关，与修饰符和返回值类型以及抛出异常类型无关

2）方法重写的前提是发生在具有继承关系的两个类之间，方法重写有以下规则：

- 参数列表必须保持一致
- 返回值类型必须保持一致
- 方法名必须保持一致
- 重写方法的访问权限范围必须大于等于父类方法
- 重写方法的抛出异常类型范围不能大于父类方法

### 2、方法的重载和重写的作用不同

重载：在一个类中为一种行为提供多种实现方式并提高可读性

重写：父类方法无法满足子类的要求，子类通过方法重写满足需求

实例：

重载：构造方法的重载、println()方法重载

重写：Object类的toString()、equals()、hashCode()等都可以被子类重写

用图表表示如下：

![img](/img/1878245-20191209090602434-834790838.png)

![img](/img/1878245-20191209090628408-1884619913.png)



## 五、接口和抽象类的区别

### 1.区别

- 抽象类允许包含某些方法的实现，而接口是不允许的；从设计级别看，为了实现由抽象类定义的类型，一个类必须定义为一个抽象类的子类，这限制了它在类图中的层次，但是接口没有这个层次的限制。
- 抽象类可以存着普通成员函数，而接口中只能存在public abstract方法。
- 抽象类中的成员变量可以实现多个权限 public private protected final等，接口中只能用 public static final修饰。
- 抽象类只能继承一个，接口可以实现多个。

图片表示：

![img](/img/interface_and_abstract.png)



## 六、List和Set

List和Set的之间的区别：首先我们来看看图解！

![这里写图片描述](/img/colllection.png)

### 1.List：

#### ArrayList

底层数据结构是数组，查询快，增删慢，线程不安全，效率高，可以存储重复元素



#### LinkedList 

底层数据结构是链表，查询慢，增删快，线程不安全，效率高，可以存储重复元素



#### Vector

底层数据结构是数组，查询快，增删慢，线程安全，效率低，可以存储重复元素

![这里写图片描述](/img/List.png)

### 2.Set：

#### HashSet

底层数据结构采用哈希表实现，元素无序且唯一，线程不安全，效率高，可以存储null元素，元素的唯一性是靠所存储元素类型是否重写hashCode()和equals()方法来保证的，如果没有重写这两个方法，则无法保证元素的唯一性。


具体实现唯一性的比较过程：存储元素首先会使用hash()算法函数生成一个int类型hashCode散列值，然后已经的所存储的元素的hashCode值比较，如果hashCode不相等，则所存储的两个对象一定不相等，此时存储当前的新的hashCode值处的元素对象；如果hashCode相等，存储元素的对象还是不一定相等，此时会调用equals()方法判断两个对象的内容是否相等，如果内容相等，那么就是同一个对象，无需存储；如果比较的内容不相等，那么就是不同的对象，就该存储了，此时就要采用哈希的解决地址冲突算法，在当前hashCode值处类似一个新的链表， 在同一个hashCode值的后面存储存储不同的对象，这样就保证了元素的唯一性。


Set的实现类的集合对象中不能够有重复元素，HashSet也一样他是使用了一种标识来确定元素的不重复，HashSet用一种算法来保证HashSet中的元素是不重复的， HashSet采用哈希算法，底层用数组存储数据。默认初始化容量16，加载因子0.75。


Object类中的hashCode()的方法是所有子类都会继承这个方法，这个方法会用Hash算法算出一个Hash（哈希）码值返回，HashSet会用Hash码值去和数组长度取模， 模（这个模就是对象要存放在数组中的位置）相同时才会判断数组中的元素和要加入的对象的内容是否相同，如果不同才会添加进去。



#### LinkedHashSet

底层数据结构采用链表和哈希表共同实现，链表保证了元素的顺序与存储顺序一致，哈希表保证了元素的唯一性。线程不安全，效率高。



#### TreeSet

底层数据结构采用二叉树来实现，元素唯一且已经排好序；唯一性同样需要重写hashCode和equals()方法，二叉树结构保证了元素的有序性。根据构造方法不同，分为自然排序（无参构造）和比较器排序（有参构造），自然排序要求元素必须实现Compareable接口，并重写里面的compareTo()方法，元素通过比较返回的int值来判断排序序列，返回0说明两个对象相同，不需要存储；比较器排需要在TreeSet初始化是时候传入一个实现Comparator接口的比较器对象，或者采用匿名内部类的方式new一个Comparator对象，重写里面的compare()方法；



#### 小结

Set具有与Collection完全一样的接口，因此没有任何额外的功能，不像前面有两个不同的List。实际上Set就是Collection,只 是行为不同。(这是继承与多态思想的典型应用：表现不同的行为。)Set不保存重复的元素。
Set 存入Set的每个元素都必须是唯一的，因为Set不保存重复元素。加入Set的元素必须定义equals()方法以确保对象的唯一性。Set与Collection有完全一样的接口。Set接口不保证维护元素的次序。





### 3.List和Set总结：

（1）、List,Set都是继承自Collection接口，Map则不是
（2）、List特点：元素有放入顺序，元素可重复 ，Set特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉，（注意：元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的，加入Set 的Object必须定义equals()方法 ，另外list支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。）
（3）、Set和List对比：
Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。
List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。
（4）、ArrayList与LinkedList的区别和适用场景



#### Arraylist：

优点：ArrayList是实现了基于动态数组的数据结构,因为地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的）。
缺点：因为地址连续， ArrayList要移动数据,所以插入和删除操作效率比较低（调优：使用尾插法并指定初始容量可以极大提升性能，甚至超过LinkedList，因为LinkedList需要创建大量node对象）。



#### LinkedList：

优点：LinkedList基于链表的数据结构,地址是任意的，所以在开辟内存空间的时候不需要等一个连续的地址，对于新增和删除操作add和remove，LinedList比较占优势。LinkedList 适用于要头尾操作或插入指定位置的场景。
缺点：因为LinkedList要移动指针,所以查询操作性能比较低。 



## 七、java类的加载器有哪些

JDK自带有三个类加载器：BootStrap ClassLoder、ExtClassLoder、AppClassLoder。

BootStrapClassLoder是ExtClassLoder的父类加载器，默认负责加载%JAVA_HOME%lib下的jar包和class文件。

ExtClassLoder是AppClassLoder的父类加载器，负责加载%JAVA_HOME%lib/ext文件下的jar包和class类。

AppClassLoder是自定义类加载器的父类，负责加载classpath下的类文件。系统加载器，线程上下文加载器。



## 八、双亲委派机制

![image-20220726104929381](/img/image-20220726104929381.png)

双亲委派机制的好处：

- 主要是为了安全性，避免用户自己编写的类动态替换Java的一些核心类，比如String。
- 同时也避免了类的重复加载，因为JVM中区分不同类，不仅仅是根据类名，相同的class文件被不同的ClassLoder加载就是不同的两个类



## 九、Java中的异常体系

- Java中的所有异常都来自顶级父类Throwable。
- Throwable下有两个子类Exception和Error。
- Exception不会导致程序停止，又分为两个部分RunTimeException运行时异常和CheckedException检查异常。
- RunTimeException常常发生在程序运行过程中，会导致程序当前线程执行失败。CheckedException常常发生在程序编译过程中，会导致程序编译不通过。
